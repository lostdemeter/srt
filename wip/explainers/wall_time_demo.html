<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRT Theory Demo: Harmony vs. Dissonance in Algorithm Execution</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #333; }
        .graph-section { display: flex; justify-content: space-around; margin: 20px 0; flex-wrap: wrap; }
        .graph { width: 30%; min-width: 300px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .tunable { text-align: center; }
        .slider-container { margin: 20px 0; }
        label { display: block; margin-bottom: 10px; font-weight: bold; }
        input[type="range"] { width: 80%; }
        #tunableChart { height: 300px; }
        .legend { text-align: center; margin-top: 10px; font-style: italic; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 10px; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h1>SRT Theory: Harmony vs. Dissonance in Execution Time</h1>
        <p style="text-align: center;">This demo simulates the Spectral Resonance Theory (SRT) oracle for prime detection (up to n=10k). <strong>Harmony</strong> (low noise, zeta damping on) converges quickly with tight eigenvalue overlaps. <strong>Dissonance</strong> (high noise, no damping) spreads spectra, increasing "wall time." The tunable graph lets you adjust simulated noise to see runtime dissonance in action.</p>
        
        <div class="graph-section">
            <div class="graph">
                <h3>Harmony Setup</h3>
                <canvas id="harmonyChart"></canvas>
                <div class="legend">Simulated Time: ~1.8s | Smooth convergence (100% recall)</div>
                <button onclick="runHarmony()">Re-run Harmony</button>
            </div>
            
            <div class="graph">
                <h3>Dissonance Setup</h3>
                <canvas id="dissonanceChart"></canvas>
                <div class="legend">Simulated Time: ~3.0s | Noisy spread (+62% time)</div>
                <button onclick="runDissonance()">Re-run Dissonance</button>
            </div>
            
            <div class="graph tunable">
                <h3>Tunable Resonance</h3>
                <canvas id="tunableChart"></canvas>
                <div class="slider-container">
                    <label for="noiseSlider">Noise Level (0=Harmony, 1=Dissonance): <span id="noiseValue">0.5</span></label>
                    <input type="range" id="noiseSlider" min="0" max="1" step="0.01" value="0.5" onchange="updateTunable()">
                </div>
                <div class="legend" id="tunableLegend">Simulated Time: 2.4s | Adjust slider to tune dissonance</div>
                <button onclick="runTunable()">Run Tunable</button>
            </div>
        </div>
        
        <p style="text-align: center; font-size: 0.9em;">Graphs show eigenvalue overlaps (resonance functional R(S)) over iterations. Lower values = better harmony. Delays simulate wall-clock time based on empirical benchmarks.</p>
    </div>

    <script>
        // Global charts
        let harmonyChart, dissonanceChart, tunableChart;
        let harmonyCtx = document.getElementById('harmonyChart').getContext('2d');
        let dissonanceCtx = document.getElementById('dissonanceChart').getContext('2d');
        let tunableCtx = document.getElementById('tunableChart').getContext('2d');

        // Base data simulation: 50 iterations, n=10k primes context
        function generateData(noise = 0.02, iterations = 50) {
            let data = [];
            let baseTrend = []; // Smooth decay for harmony
            for (let i = 0; i < iterations; i++) {
                baseTrend.push(1 - (i / iterations) * 0.8); // Converge to low R(S)
            }
            for (let i = 0; i < iterations; i++) {
                let val = baseTrend[i] + (Math.random() - 0.5) * noise * 2; // Noise perturbation
                if (noise > 0.3) val += Math.sin(i * 0.5) * 0.3; // Add oscillatory dissonance
                data.push(Math.max(0, val));
            }
            return data;
        }

        // Simulate delay based on noise (empirical scaling)
        function simulateDelay(noise) {
            const baseTime = 1800; // ms for harmony
            const dissonanceMultiplier = 1 + noise * 1.5; // Up to +150% at noise=1
            return baseTime * dissonanceMultiplier / 50; // Per iteration, but total for run
        }

        // Run with animation (progressive data reveal)
        async function runWithAnimation(ctx, chart, data, totalDelay) {
            chart.data.datasets[0].data = [];
            chart.update();
            let cumulativeDelay = 0;
            for (let i = 0; i < data.length; i++) {
                setTimeout(() => {
                    chart.data.datasets[0].data[i] = data[i];
                    chart.update();
                }, cumulativeDelay);
                cumulativeDelay += totalDelay / data.length;
            }
            await new Promise(resolve => setTimeout(resolve, totalDelay));
        }

        // Harmony runner
        async function runHarmony() {
            const data = generateData(0.02);
            const delay = simulateDelay(0.02);
            await runWithAnimation(harmonyCtx, harmonyChart, data, delay);
        }

        // Dissonance runner
        async function runDissonance() {
            const data = generateData(0.5);
            const delay = simulateDelay(0.5);
            await runWithAnimation(dissonanceCtx, dissonanceChart, data, delay);
        }

        // Tunable runner
        function runTunable() {
            const noise = parseFloat(document.getElementById('noiseSlider').value);
            const data = generateData(noise);
            const delay = simulateDelay(noise);
            runWithAnimation(tunableCtx, tunableChart, data, delay).then(() => {
                document.getElementById('tunableLegend').textContent = `Simulated Time: ${delay.toFixed(1)}ms | Noise: ${noise.toFixed(2)}`;
            });
        }

        // Update tunable on slider change (quick preview without full run)
        function updateTunable() {
            const noise = parseFloat(document.getElementById('noiseSlider').value);
            document.getElementById('noiseValue').textContent = noise.toFixed(2);
            // Quick static update for preview
            const data = generateData(noise);
            tunableChart.data.datasets[0].data = data;
            tunableChart.update();
            const delay = simulateDelay(noise);
            document.getElementById('tunableLegend').textContent = `Simulated Time: ${delay.toFixed(1)}ms | Noise: ${noise.toFixed(2)} (preview)`;
        }

        // Initialize charts
        function initCharts() {
            harmonyChart = new Chart(harmonyCtx, {
                type: 'line',
                data: { labels: Array.from({length: 50}, (_, i) => `Iter ${i+1}`), datasets: [{ label: 'R(S) Resonance', data: [], borderColor: 'green', fill: false }] },
                options: { responsive: true, scales: { y: { min: 0, max: 1 } }, plugins: { legend: { display: false } } }
            });

            dissonanceChart = new Chart(dissonanceCtx, {
                type: 'line',
                data: { labels: Array.from({length: 50}, (_, i) => `Iter ${i+1}`), datasets: [{ label: 'R(S) Resonance', data: [], borderColor: 'red', fill: false }] },
                options: { responsive: true, scales: { y: { min: 0, max: 1 } }, plugins: { legend: { display: false } } }
            });

            tunableChart = new Chart(tunableCtx, {
                type: 'line',
                data: { labels: Array.from({length: 50}, (_, i) => `Iter ${i+1}`), datasets: [{ label: 'R(S) Resonance', data: [], borderColor: 'blue', fill: false }] },
                options: { responsive: true, scales: { y: { min: 0, max: 1 } }, plugins: { legend: { display: false } } }
            });
        }

        // Init on load
        window.onload = () => {
            initCharts();
            // Auto-run initial demos
            runHarmony();
            runDissonance();
            runTunable();
        };
    </script>
</body>
</html>
